<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Python 描述器"><meta name="keywords" content="python,descriptor"><meta name="author" content="zgzhong,undefined"><meta name="copyright" content="zgzhong"><title>Python 描述器 | Pluviophile's Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#描述器"><span class="toc-number">1.</span> <span class="toc-text">描述器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象的属性"><span class="toc-number">2.</span> <span class="toc-text">对象的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#描述器的简洁写法"><span class="toc-number">2.1.</span> <span class="toc-text">描述器的简洁写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用途"><span class="toc-number">2.2.</span> <span class="toc-text">用途</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.imgur.com/3Q8dIiP.jpg?1"></div><div class="author-info__name text-center">zgzhong</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Lisupy" target="_blank">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.imgur.com/DBI8I6q.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Pluviophile's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Posts</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Python 描述器</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-03-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python/">python</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h1><p>描述器是一个具有“绑定”行为的对象<font color="red">属性</font>【object attribute， 与之对应的是类属性（class attribute）】，<em>注意是属性</em>。这个属性的访问行为控制被描述器协议的方法重写。这些方法只有三个，它们是 <code>__get__()</code>, <code>__set__()</code>和 <code>__delete__()</code>，定义了这三个方法中的任意一个对象就叫做<strong>描述器</strong></p>
<a id="more"></a>
<blockquote>
<p>和装饰器、迭代器一样，描述器要发挥作用也必须在特定场合中，也就是作为对象属性时才会发挥作用(装饰器要用@，迭代器用于next的迭代操作)，</p>
</blockquote>
<hr>
<h1 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h1><p>在讨论描述器之前，我们先来看一下对象的属性有什么特点</p>
<font color="navy">在Python中一切皆是对象</font>，所以类也是对象，类的实例也是对象——<strong>所有的对象都有属性，所以实际上属性是整个Python的基础</strong>——在每个对象中都有一个<code>__dict__</code>属性，其中包含的是它所有的属性。类也不例外，类的<code>__dict__</code>中包含的属性称为类属性，<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">55</span>]: <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...:     class_attr = <span class="number">1</span></span><br><span class="line">    ...:     </span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: MyClass.__dict__</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">mappingproxy(&#123;<span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'MyClass'</span> objects&gt;,</span><br><span class="line">              <span class="string">'__doc__'</span>: <span class="keyword">None</span>,</span><br><span class="line">              <span class="string">'__module__'</span>: <span class="string">'__main__'</span>,</span><br><span class="line">              <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'MyClass'</span> objects&gt;,</span><br><span class="line">              <span class="string">'class_attr'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><br><br>除了类以外，每个实例(instance)也有相应的属性表(<code>__dict__</code>),称为实例属性。我们通过实例访问属性时，解释器将首先会在实例属性中查找，如果找不到，那么将会继续在类属性中查找。<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_instance = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_instance.__dict__</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_instance.class_attr</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><br><br>通过实例添加、修改属性并不会对类属性产生修改，因此此时类属性对实例来说是只读的。看代码<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_instance.class_attr = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_instance.class_attr</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;my_instance.__dict__</span><br><span class="line">&#123;<span class="string">'class_attr'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass.class_attr</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'MyClass'</span> objects&gt;,</span><br><span class="line">              <span class="string">'__doc__'</span>: <span class="keyword">None</span>,</span><br><span class="line">              <span class="string">'__module__'</span>: <span class="string">'__main__'</span>,</span><br><span class="line">              <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'MyClass'</span> objects&gt;,</span><br><span class="line">              <span class="string">'class_attr'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><br><br>既然没有办法通过实例来添加和修改类属性，那么可不可以给类增加一个属性呢? 这个要分情况，如果这个类是自定义的类，那么是可以通过<code>.</code>作用符添加、修改属性的；如果是内置类型是不能够随意地为其添加属性或方法的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &gt;&gt;&gt; str.new_attr = <span class="number">1</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-1</span><span class="number">-84</span>d3b8160e5d&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 str.new_attr = 1</span><br><span class="line">TypeError: can<span class="string">'t set attributes of built-in/extension type '</span>st<span class="string">r'</span></span><br></pre></td></tr></table></figure><br><br><strong>至此，我们知道了<code>.</code>操作符封装了两种访问方法</strong><br>1. 如果访问的是实例属性，与直接通过<strong>dict</strong>属性获取相应元素是一样的操作。<br>2. 如果访问的是类属性，则并不是一样的操作。<br><br><br>然而，<code>.</code> 操作符封装了对实例属性和类属性查找的细节，但是我们只说了一半的事实，还有一部分没有说明，就是<font color="red">描述器机制</font><br>在上面的说明中，我们知道访问<strong>类属性</strong>时，通过<code>__dict__</code>和通过<code>.</code>操作符访问是相同的操作，但是如果是方法，却又是不一样了<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># ... other code</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"It's testing"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_instance = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_instance.test()</span><br><span class="line">It<span class="string">'s testing</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; MyClass.test()</span></span><br><span class="line"><span class="string">------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">TypeError                                 Traceback (most recent call last)</span></span><br><span class="line"><span class="string">&lt;ipython-input-56-af57521a76c1&gt; in &lt;module&gt;()</span></span><br><span class="line"><span class="string">----&gt; 1 MyClass.test()</span></span><br><span class="line"><span class="string">test() missing 1 required positional argument: '</span>sel<span class="string">f'  # 在Python3 中这么显示 在Python2中显示为unbound method (Python3 中没有unbound method)这里不深究为什么</span></span><br></pre></td></tr></table></figure><br><br>#描述器协议<br><strong>这时我们就要来说明描述器这个神器了</strong><br>描述器很强大，并且应用广泛。是 <strong>属性</strong>、<strong>实例方法</strong>、<strong>静态方法</strong>、<strong>类方法</strong>和<code>super</code>的背后机制。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">descr.__get__(self, obj, type=None) --&gt; value</span><br><span class="line">descr.__set__(self, obj, value) --&gt; None</span><br><span class="line">descr.__delete__(self, obj) --&gt; None</span><br></pre></td></tr></table></figure><br><br>上述的就是所有的描述器方法，一个对象具有其中的任何一个方法就会成为描述器，从而在被当做 <font color="navy"><strong>对象属性</strong></font> 访问时将重写默认的查找行为。由于实例方法属于描述器，所以会发生上面类调用方法和对象调用方法是产生的相异行为。<br><br>如果一个对象<em>(上文提到的Python中万物皆对象，函数也是对象)</em>同时定义了 <code>__get__()</code> 和 <code>__set__()</code>,它叫做数据描述器(有种另外的叫法叫做资料描述器(data descriptor)。仅定义了 <code>__get__()</code> 的描述器叫非数据描述器(non-data descriptor)(常用于方法，当然其他用途也是可以的)<br><br>数据描述器和非数据描述器的区别在于——相对于实例的字典(<code>instance.__dict__</code>)的优先级。如果实例字典中有与描述器同名的属性，如果描述器是数据描述器，优<br><br>先使用数据描述器，如果是非数据描述器，优先使用字典中的属性。(译者注：这就是为何实例 <code>a</code> 的方法和属性重名时，比如都叫 foo Python会在访问 a.foo 的时候优先访问实例字典中的属性，因为实例函数的实现是个非数据描述器)<br><br>要想制作一个只读的数据描述器，需要同时定义 <code>__set__</code> 和 <code>__get__</code>,并在 <code>__set__</code> 中引发一个 AttributeError 异常。定义一个引发异常的 <code>__set__</code> 方法就足够让一个描述器成为数据描述器。<br><br>## 描述器的调用<br>描述器可以直接这么调用： <code>descriptor.__get__(obj)</code><br>然而更常见的情况是描述器在属性访问时被调用，举个例子来说<code>obj.desc</code>会在<code>obj</code>的字典中寻找<code>d</code>，如果<code>desc</code>定义了<code>__get__()</code>方法(即desc是一个描述器)，将会按照下面的优先规则顺序被调用：<br><br>Note: 调用的详细信息取决于obj是类还是对象<br><br>小知识：对于属性访问来说都会默认无条件的调用<code>__getattribute__()</code>方法。<a href="/python/2017/03/11/__getattribute__-vs-__getattr__.html">详细链接</a><br><br>对于对象来说，<code>object.__getattribute__()</code>方法会把<code>obj.desc</code>变成 type(obj).<strong>dict</strong>[‘desc’].<strong>get</strong>(obj, type(obj))。具体是实现顺序是:<br>&gt; data descriptor &gt; instance variable &gt; non-data descriptor &gt; _getattr__()<br>&gt; 关于<strong>getattr</strong>()参见 笔记 <a href="/python/2017/03/11/__getattribute__-vs-__getattr__.html"><strong>getattr</strong></a><br><br>对于类来说: <code>type.__getattribute__()</code>——也就是<code>B.__getattribute__()</code>, B是类名称—— 把<code>obj.desc</code>变成了<code>obj.__dict__[&#39;desc&#39;].__get__(None, obj)</code> <font color="green">(注意此时obj是类不是对象)</font>


<p>可以总结几个要点：</p>
<ul>
<li>描述器的调用是因为 <code>__getattribute__()</code></li>
<li>重写 <code>__getattribute__()</code> 方法会阻止正常的描述器调用</li>
<li><code>object.__getattribute__()</code> 和 <code>type.__getattribute__()</code> 对 <code>__get__()</code> 的调用不一样</li>
<li>资料描述器总是比实例字典优先。</li>
<li>非资料描述器可能被实例字典重写。(非资料描述器不如实例字典优先)</li>
</ul>
<blockquote>
<p><code>super()</code> 返回的对象同样有一个定制的 <code>__getattribute__()</code> 方法用来调用描述器。调用 <code>super(B, obj).m()</code> 时会先在 <code>obj.__class__.__mro__</code>中查找与B紧邻的基类<code>A</code>，然后返回 <code>A.__dict__[&#39;m&#39;].__get__(obj, A)</code> 。如果不是描述器，原样返回 <code>m</code> 。如果实例字典中找不到 <code>m</code> ，会回溯继续调用 <code>object.__getattribute__()</code> 查找。(即在 <strong>mro</strong> 中的下一个基类中查找)</p>
</blockquote>
<blockquote>
<p>需要注意的点：<strong>描述器只在对象属性访问</strong>和<strong>在类属性的只读访问</strong>时起作用，如果通过类属性的方式修改描述器和删除描述器，都将造成对应的类属性被重写或删除。描述器是在Class 中被赋值的，而在对象属性访问而生效的。</p>
</blockquote>
<p>这样的话在本笔记上面类调用函数和实例调用函数的区别就明了了，由于<code>__getattribute__()</code>调用的不同，而且方法是一个描述器(非数据)。实例调用方法时传入描述器方法<code>__get__()</code>时包含了该实例。那么可以使用偏函数的形式忽略第一个参数<code>self</code>(我的理解)。而类调用方法传入的描述器方法<code>__get__()</code>中实例传入的是None，因此就解决了上述的问题。</p>
<h2 id="描述器的简洁写法"><a href="#描述器的简洁写法" class="headerlink" title="描述器的简洁写法"></a>描述器的简洁写法</h2><ol>
<li><p>使用<code>property()</code>是建立数据描述器的一种简洁方法，从而可以在访问属性时触发相应的方法调用。这个函数的原型:<br><code>property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</code></p>
</li>
<li><p>描述器的构造可以通过使用修饰器来构造,此时装饰器叫做@property，见<a href="/python/2017/03/12/装饰器+描述器以及描述器的妙用.html">装饰器+描述器的黑魔法</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._name = <span class="string">''</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Getting: %s"</span> % self._name</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Setting: %s"</span> % value</span><br><span class="line">        self._name = value.title()</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @name.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&gt;Deleting: %s"</span> % self._name</span><br><span class="line">        <span class="keyword">del</span> self._name</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>当用户接口已经被授权访问属性之后，需求发生一些变化，属性需要进一步处理才能返回给用户。这时 property() 能够提供很大帮助。</p>
<p>例如，一个电子表格类提供了访问单元格的方式: Cell(‘b10’).value 。 之后，对这个程序的改善要求在每次访问单元格时重新计算单元格的值。然而，程序员并不想影响那些客户端中直接访问属性的代码。那么解决方案是将属性访问包装在一个属性数据描述器中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span><span class="params">(object)</span>:</span></span><br><span class="line">    . . .</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getvalue</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"Recalculate cell before returning value"</span></span><br><span class="line">        self.recalc()</span><br><span class="line">        <span class="keyword">return</span> obj._value</span><br><span class="line">    value = property(getvalue)</span><br></pre></td></tr></table></figure></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zgzhong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://lisupy.github.io/2017/03/09/Python Descriptor/">http://lisupy.github.io/2017/03/09/Python Descriptor/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/descriptor/">descriptor</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://i.imgur.com/4YlAU5b.png"><div class="post-qr-code__desc">文章看完了，请我喝杯茶？</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/03/12/装饰器+描述器以及描述器的妙用/"><i class="fa fa-chevron-left">  </i><span>装饰器+描述器 以及描述器的妙用</span></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By zgzhong</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, Welcome to my blog! Follow me on <a href="https://github.com/Lisupy">github</a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>